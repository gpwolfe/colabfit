"""
File notes:
-------------------
copy-paste of example header line from xyz files for ingest
Lattice="5.58828896 -0.0 0.0 0.0 5.78609927 0.0 0.0 0.0 15.33467811" Properties=species:S:1:pos:R:3:forces:R:3 e_fr_energy=-288.44648029 e_wo_entrp=-288.44648029 e_0_energy=0.0 stress="-51.57181753 0.0 0.0 0.0 -37.19938692 0.0 0.0 0.0 -40.7745395" outcar-electrostatic_potential="-39.6083 -39.6083 -39.6083 -39.6083 -39.6083 -39.6083 -39.6083 -39.6083 -48.1737 -48.1737 -48.1737 -48.1737 -72.6278 -72.7764 -72.7764 -72.7764 -72.6703 -72.7764 -72.6278 -72.6703 -72.6703 -72.7764 -72.6278 -72.6278 -72.6703 -72.6278 -72.6278 -72.7764 -72.6278 -72.6703 -72.6703 -72.7764 -72.7764 -72.6703 -72.6703 -72.6278" outcar-efermi=1.9812 outcar-magnetization-tot="0.03 0.03 0.03 0.03 0.03 0.03 0.03 0.03 3.765 3.765 3.765 3.765 0.019 0.031 0.031 0.03 0.003 0.031 0.019 0.003 0.003 0.03 0.019 0.019 0.003 0.019 0.019 0.03 0.019 0.003 0.003 0.03 0.031 0.003 0.003 0.019" outcar-magnetization-d="0.027 0.027 0.027 0.027 0.027 0.027 0.027 0.027 3.719 3.719 3.719 3.719 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0" outcar-magnetization-p="0.001 0.001 0.001 0.001 0.001 0.001 0.001 0.001 0.019 0.019 0.019 0.019 0.016 0.025 0.025 0.025 0.003 0.025 0.016 0.003 0.003 0.025 0.016 0.016 0.003 0.016 0.016 0.025 0.016 0.003 0.003 0.025 0.025 0.003 0.003 0.016" outcar-magnetization-s="0.001 0.001 0.001 0.001 0.001 0.001 0.001 0.001 0.027 0.027 0.027 0.027 0.003 0.005 0.005 0.005 0.0 0.005 0.003 0.0 0.0 0.005 0.003 0.003 0.0 0.003 0.003 0.005 0.003 0.0 0.0 0.005 0.005 0.0 0.0 0.003" outcar-nelect=288.0000045 outcar-drift="-0.0 -0.0 -0.0 -0.0 -0.0 -0.0 -0.0 -0.0 -0.0 -0.0 -0.0 -0.0 -0.0 -0.0 -0.0 -0.0 -0.0 -0.0 -0.0 -0.0 -0.0 -0.0 -0.0 -0.0 -0.0 -0.0 -0.0 -0.0 -0.0 -0.0 -0.0 -0.0 -0.0 -0.0 -0.0 -0.0 -0.0 -0.0 -0.0 -0.0 -0.0 -0.0 -0.0 -0.0 -0.0 -0.0 -0.0 -0.0 -0.0 -0.0 -0.0 -0.0 -0.0 -0.0 -0.0 -0.0 -0.0 -0.0 -0.0 -0.0 -0.0 -0.0 -0.0 -0.0 -0.0 -0.0 -0.0 -0.0 -0.0 -0.0 -0.0 -0.0 -0.0 -0.0 -0.0 -0.0 -0.0 -0.0 -0.0 -0.0 -0.0 -0.0 -0.0 -0.0 -0.0 -0.0 -0.0 -0.0 -0.0 -0.0 -0.0 -0.0 -0.0 -0.0 -0.0 -0.0 -0.0 -0.0 -0.0 -0.0 -0.0 -0.0 -0.0 -0.0 -0.0 -0.0 -0.0 -0.0 -0.0 -0.0 -0.0 -0.0 -0.0 -0.0 -0.0 -0.0 -0.0 -0.0 -0.0 -0.0 -0.0 -0.0 -0.0 -0.0 -0.0 -0.0 -0.0 -0.0 -0.0 -0.0 -0.0 -0.0 -0.0 -0.0 -0.0 -0.0 -0.0 -0.0 -0.0 -0.0 -0.0 -0.0 -0.0 -0.0 -0.0 -0.0 -0.0 -0.0 -0.0 -0.0 -0.0 -0.0 -0.0 -0.0 -0.0 -0.0 -0.0 -0.0 -0.0 -0.0 -0.0 -0.0 -0.0 -0.0 -0.0 -0.0 -0.0 -0.0 -0.0 -0.0 -0.0 -0.0 -0.0 -0.0 0.0 -0.0 -0.0 -0.0 -0.0 0.0 -0.0 0.0 0.0 0.0 -0.0 0.0 -0.0 0.0 -0.0 -0.0 -0.0 0.0 -0.0 -0.0 0.0 0.0 0.0 -0.0 0.0 0.0 0.0 -0.0 0.0 0.0 0.0 -0.0 0.0 -0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 -0.0 -0.0 0.0 -0.0 0.0 -0.0 -0.0 -0.0 0.0 0.0 0.0 0.0 -0.0 0.0 0.0 -0.0 0.0 0.0 -0.0 0.0 -0.0 -0.0 0.0 0.0 0.0 0.0 -0.0 -0.0 0.0 -0.0 -0.0 0.0 0.0 -0.0 0.0 -0.0 -0.0 0.0 0.0 -0.0 -0.0 -0.0 -0.0 0.0 0.0" outcar-total_magnetization=16.0000007 outcar-ngf="96 100 252" outcar-is_stopped=F outcar-sampling_radii="1.2125 0.95 0.7215" outcar-charge-tot="9.813 9.814 9.813 9.814 9.813 9.814 9.813 9.814 12.354 12.354 12.354 12.354 5.051 5.026 5.026 5.025 5.045 5.026 5.051 5.042 5.042 5.025 5.052 5.051 5.045 5.052 5.051 5.025 5.052 5.045 5.045 5.025 5.026 5.042 5.042 5.052" outcar-charge-d="2.813 2.815 2.813 2.815 2.813 2.815 2.813 2.815 5.943 5.943 5.943 5.943 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0" outcar-charge-p="6.575 6.574 6.575 6.574 6.575 6.574 6.575 6.574 6.209 6.209 6.209 6.209 3.488 3.453 3.453 3.452 3.484 3.453 3.488 3.482 3.482 3.452 3.489 3.488 3.484 3.489 3.488 3.452 3.489 3.484 3.484 3.452 3.453 3.482 3.482 3.489" outcar-charge-s="0.426 0.425 0.426 0.425 0.426 0.425 0.426 0.425 0.203 0.203 0.203 0.203 1.563 1.573 1.573 1.573 1.561 1.573 1.563 1.56 1.56 1.573 1.563 1.563 1.561 1.563 1.563 1.573 1.563 1.561 1.561 1.573 1.573 1.56 1.56 1.563" incar-ISMEAR=-5 incar-LORBIT=11 incar-LDAUTYPE=2 incar-PREC=accurate incar-LWAVE=F incar-ISPIN=2 incar-LDAUJ="0.0 0.0 0.0" incar-LMAXMIX=4 incar-NELM=100 incar-LDAUL="0 2 0" incar-IBRION=2 incar-LDAUU="0.0 5.3 0.0" incar-ALGO=Fast incar-LREAL=Auto incar-ICHARG=1 incar-EDIFF=0.0018 incar-NSW=99 incar-MAGMOM="0.6 0.6 0.6 0.6 0.6 0.6 0.6 0.6 5.0 5.0 5.0 5.0 0.6 0.6 0.6 0.6 0.6 0.6 0.6 0.6 0.6 0.6 0.6 0.6 0.6 0.6 0.6 0.6 0.6 0.6 0.6 0.6 0.6 0.6 0.6 0.6" incar-LDAUPRINT=1 incar-ISIF=3 incar-LDAU=T incar-KPOINT_BSE="-1 0 0 0" incar-POTIM=0.25 incar-ENCUT=520.0 incar-SIGMA=0.05 output-vbm=1.9758 output-epsilon_static= output-efermi=1.98121657 output-epsilon_ionic= output-bandgap=1.9668 output-energy=-305.09556914 output-is_metal=F output-energy_per_atom=-8.474876920555555 output-is_gap_direct=F output-epsilon_static_wolfe= output-direct_gap=2.0345 output-cbm=3.9426 material_id=mp-1180571 task_id=mp-1180571 name=mp-1180571-1-8 calc_type="GGA+U Structure Optimization" pbc="T T T" # noqa E501

"""
from argparse import ArgumentParser
from ase.io import read
from colabfit import ATOMS_LABELS_FIELD, ATOMS_NAME_FIELD
from colabfit.tools.converters import AtomicConfiguration
from colabfit.tools.database import MongoDatabase, generate_ds_id
from colabfit.tools.property_definitions import (
    atomic_forces_pd,
    cauchy_stress_pd,
    free_energy_pd,
)
import functools
import itertools
import logging
from multiprocessing import Pool
import numpy as np
from pathlib import Path
import pymongo
import sys
from datetime import datetime
import time

BATCH_SIZE = 100
START_IX = 0  # for testing, in case of errors causing script stop

# Local
# DATASET_FP = Path("materials_project/mat_proj_xyz_files")

# Greene
DATASET_FP = Path(
    "/vast/gw2338/materials_project/materials_project/mat_proj_xyz_files_expanded_data/"
)

# Kubernetes
# DATASET_FP = Path(
#     "/persistent/colabfit_raw_data/gw_scripts_large/large_scripts_data/"
#     "materials_project/mat_proj_xyz_files"
# )
DATASET = "Materials Project"
PUBLICATION = "https://doi.org/10.1063/1.4812323"
DATA_LINK = "https://materialsproject.org"
LINKS = ["https://materialsproject.org", "https://doi.org/10.1063/1.4812323"]
AUTHORS = [
    "Anubhav Jain",
    "Shyue Ping Ong",
    "Geoffroy Hautier",
    "Wei Chen",
    "William Davidson Richards",
    "Stephen Dacek",
    "Shreyas Cholia",
    "Dan Gunter",
    "David Skinner",
    "Gerbrand Ceder",
    "Kristin A. Persson",
]
DS_DESC = (
    "Configurations from the Materials Project database:"
    " an online resource with the goal of computing properties of all"
    " inorganic materials."
)

GLOB_STR = "*.xyz"

ELEMENTS = [
    "H",
    "He",
    "Li",
    "Be",
    "B",
    "C",
    "N",
    "O",
    "F",
    "Ne",
    "Na",
    "Mg",
    "Al",
    "Si",
    "P",
    "S",
    "Cl",
    "Ar",
    "K",
    "Ca",
    "Sc",
    "Ti",
    "V",
    "Cr",
    "Mn",
    "Fe",
    "Co",
    "Ni",
    "Cu",
    "Zn",
    "Ga",
    "Ge",
    "As",
    "Se",
    "Br",
    "Kr",
    "Rb",
    "Sr",
    "Y",
    "Zr",
    "Nb",
    "Mo",
    "Tc",
    "Ru",
    "Rh",
    "Pd",
    "Ag",
    "Cd",
    "In",
    "Sn",
    "Sb",
    "Te",
    "I",
    "Xe",
    "Cs",
    "Ba",
    "La",
    "Ce",
    "Pr",
    "Nd",
    "Pm",
    "Sm",
    "Eu",
    "Gd",
    "Tb",
    "Dy",
    "Ho",
    "Er",
    "Tm",
    "Yb",
    "Lu",
    "Hf",
    "Ta",
    "W",
    "Re",
    "Os",
    "Ir",
    "Pt",
    "Au",
    "Hg",
    "Tl",
    "Pb",
    "Bi",
    "Ac",
    "Th",
    "Pa",
    "U",
    "Np",
    "Pu",
]

MAX_AUTO_RECONNECT_ATTEMPTS = 100
metadata = {
    "software": {"value": "VASP"},
    "method": {"field": "calc_type"},
    "input": {"field": "input"},
}
# excluded keys are included under other names or in property_map
exclude = {"calc_type", "e_fr_energy", "forces", "stress", "material_id"}
co_md_map = {
    "material-id": {"field": "material_id"},
    "internal_energy": {"field": "e_0_energy"},
}

KEYS = [
    "calc_type",
    "e_0_energy",
    "e_fr_energy",
    "e_wo_entrp",
    # "incar",  # including as input in PI MD
    "material_id",
    "name",
    "outcar",
    "output",
    "stress",
    "task_id",
]

co_md_map.update({k: {"field": k} for k in KEYS if k not in exclude})
property_map = {
    "free-energy": [
        {
            "energy": {"field": "e_fr_energy", "units": "eV"},
            "per-atom": {"value": False, "units": None},
            "_metadata": metadata,
        }
    ],
    "atomic-forces": [
        {
            "forces": {"field": "forces", "units": "eV/A"},
            "_metadata": metadata,
        }
    ],
    "cauchy-stress": [
        {
            "stress": {"field": "stress", "units": "eV/A"},
            "_metadata": metadata,
        }
    ],
}
NAME_FIELD = "name"
LABEL_FIELD = "labels"


def reconstruct_nested(info: dict, superkey: str):
    """
    Create dicts, nested if necessary, for configuration info from xyz headers.

    Incar, outcar and output information will be gathered from Mat. Proj. xyz file
    headers, checked for incorrect values (where info value contains another key-value
    pair), and gathered into a single, nested (if necessary) dictionary, and returned.
    """
    in_out_car = dict()
    for key, val in info.items():
        # Some values in header are blank, so ase.io.read returns key1 = "key2=val2"
        if isinstance(val, str) and "=" in val:
            key, val = val.split("=")[-2:]
            if val != "F":
                try:
                    val = float(val)
                except ValueError:
                    pass
        if superkey in key:
            # pymongo/MongoDB throws error regarding use of numpy objects:
            # bson.errors.InvalidDocument: cannot encode object: 100, \
            # of type: <class 'numpy.int64'>
            if isinstance(val, np.ndarray):
                val = val.tolist()
            if isinstance(val, np.int64):
                val = int(val)
            outkey = key.split("-")
            if len(outkey) == 2:
                in_out_car[outkey[1]] = val
            elif len(outkey) == 3:
                if not in_out_car.get(outkey[1]):
                    in_out_car[outkey[1]] = {outkey[2]: val}
                else:
                    in_out_car[outkey[1]][outkey[2]] = val
    return in_out_car


def auto_reconnect(mongo_func):
    """Gracefully handle a reconnection event."""

    @functools.wraps(mongo_func)
    def wrapper(*args, **kwargs):
        for attempt in range(MAX_AUTO_RECONNECT_ATTEMPTS):
            try:
                return mongo_func(*args, **kwargs)
            except pymongo.errors.AutoReconnect as e:
                wait_t = 0.5 * pow(2, attempt)  # exponential back off
                logging.warning(
                    "PyMongo auto-reconnecting... %s. Waiting %.1f seconds.",
                    str(e),
                    wait_t,
                )
                time.sleep(wait_t)

    return wrapper


def reader(file_path):
    configs = read(file_path, index=":")
    for i, config in enumerate(configs):
        info = dict()
        info["outcar"] = reconstruct_nested(config.info, "outcar")
        info["output"] = reconstruct_nested(config.info, "output")
        info["input"] = reconstruct_nested(config.info, "incar")
        for key, val in config.info.items():
            if not any([match in key for match in ["outcar", "incar", "output"]]):
                if isinstance(val, str) and "=" in val:
                    key, val = val.split("=")[-2:]
                    if val != "F":
                        try:
                            val = float(val)
                        except ValueError:
                            pass
                info[key] = val
        # yield config
        atoms = AtomicConfiguration(
            numbers=config.numbers,
            positions=config.positions,
            cell=config.cell,
            pbc=config.pbc,
        )
        atoms.info = info
        atoms.info["forces"] = config.arrays["forces"]
        yield atoms


def get_configs(fpaths):
    configs = []
    for fpath in fpaths:
        try:
            new = reader(fpath)

            for i, atoms in enumerate(new):
                if NAME_FIELD in atoms.info:
                    name = []
                    name.append(atoms.info[NAME_FIELD])
                    atoms.info[ATOMS_NAME_FIELD] = name
                else:
                    raise RuntimeError(
                        f"Field {NAME_FIELD} not in atoms.info for index "
                        f"{i} in {fpath}. Set `NAME_FIELD=None` "
                        "to use `default_name`."
                    )

                if LABEL_FIELD not in atoms.info:
                    atoms.info[ATOMS_LABELS_FIELD] = set()
                else:
                    atoms.info[ATOMS_LABELS_FIELD] = set(atoms.info[LABEL_FIELD])
                configs.append(atoms)

        except Exception as e:
            with open("ingest_mp_error_files.log", "a") as f:
                f.write(
                    f"{fpath}\t{datetime.strftime(datetime.now(), '%d-%b-%Y')}"
                    f"\t{e}\n"
                )
    return configs


@auto_reconnect
def main(ip, port, db_name, nprocs):
    # client = MongoDatabase(db_name, nprocs=nprocs, uri=f"mongodb://{ip}:27017")
    client = MongoDatabase(db_name, nprocs=nprocs, uri=f"mongodb://{ip}:{port}")
    ds_id = generate_ds_id()
    for pd in [
        atomic_forces_pd,
        cauchy_stress_pd,
        free_energy_pd,
    ]:
        client.insert_property_definition(pd)

    ids = []
    fps = sorted(list(DATASET_FP.rglob(GLOB_STR)))[START_IX:]
    if len(fps) < BATCH_SIZE:
        indices = [(0, len(fps))]
    else:
        n_batches = len(fps) // BATCH_SIZE
        leftover = len(fps) % BATCH_SIZE
        indices = [((b * BATCH_SIZE, (b + 1) * BATCH_SIZE)) for b in range(n_batches)]
        if leftover:
            indices.append((BATCH_SIZE * n_batches, len(fps)))
    slices = [(fps[batch[0] : batch[1]]) for batch in indices]
    with Pool(nprocs) as pool:
        configurations = list(
            itertools.chain.from_iterable(pool.map(get_configs, slices))
        )
    ids.extend(
        list(
            client.insert_data(
                configurations,
                ds_id=ds_id,
                co_md_map=co_md_map,
                property_map=property_map,
                generator=False,
                verbose=False,
            )
        )
    )

    all_co_ids, all_do_ids = list(zip(*ids))

    client.insert_dataset(
        do_hashes=all_do_ids,
        ds_id=ds_id,
        name=DATASET,
        authors=AUTHORS,
        links=[PUBLICATION, DATA_LINK],
        description=DS_DESC,
        verbose=True,
    )


if __name__ == "__main__":
    parser = ArgumentParser()
    parser.add_argument("-i", "--ip", type=str, help="IP of host mongod")
    parser.add_argument(
        "-d",
        "--db_name",
        type=str,
        help="Name of MongoDB database to add dataset to",
        default="cf-test",
    )
    parser.add_argument(
        "-p",
        "--nprocs",
        type=int,
        help="Number of processors to use for job",
        default=4,
    )
    parser.add_argument("-r", "--port", type=int, help="Target port for MongoDB")
    args = parser.parse_args(sys.argv[1:])

    ip = args.ip
    nprocs = args.nprocs
    db_name = args.db_name
    port = args.port
    main(ip, port, db_name, nprocs)
